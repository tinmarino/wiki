```ps1
# Get-Help
##########
Get-Help | more
Get-Help *  # List all commands with help
Get-Help *process
Alias
# Hands-on: List 10 Alias useful for TUI


# Cmdlet
########
Get-Command -CommandType cmdlet -Name *process*
... | Measure-Object  # To count lines
Get-Process -Name Notepad
Stop-Process -Id 12345
Get-Hotfix  # List hotfix installed
# Hands-on: List 10 Cmdlet useful for pentest

# Output formatting
###################
Get-Command -CommandType Cmdlet -Name Format*
Get-ChildItem | Format-Table Name
Get-ChildItem | Format-Table *
Get-ChildItem | Out-File 
Get-ChildItem 2>&1 | Out-File outfile.txt
cat input.txt >> output.txt  # Redirection

# Operator
##########
1 + 2 - 3 * 4 / 5 % 6   # Out: 0.6
$a = 0; $a += 12; $a   # Assign
# Cmp with: -eq -ne -gt -lt -ge -le
# Cmp with: -match -notmatch -replace 
# Cmp with: -like -notlike -in -notin
# Cmp with: -contains -notcontains
# Info: The leftmost value imposes the type

# Advanced Operator
###################
1 -and 2 -or 3 -xor 4 -and -not 6  # Logical
"a,b,c,d" -split ","  
1,2,3,4 -join "|"
(1 -le 3) -or (1 -ge 3)
"assad" -isnot "int"
0x12 -as "int"  # Out: 18
$var = 2
$var.GetType()

# Array
#######
[int]$a = 4.3  # Casting
$arr = 1,2,3
$arr.length
$arr[0]
$arr = 1, "str"  # Linked list
$empty = @()
# Hands-on: Create a strongly typed array

# Condition
###########
if (1 -gt 0){"one"} else {""}
switch (1){1 {"one"} default {"two"}}
switch -wildcard ($var) {a* {"A"}}

# Loop
######
while(1 -eq 1){"one"}
do {"one"} while(1 -eq 1)
$a=1; do {$a++; $a} until ($a -ge 10)
for (;;){42}
foreach ($a in 1,2,3){$a}
$a_proc = Get-Process
foreach ($proc in $a_proc) {$proc.Name}
Get-ChildItem | Where-Object {$_.Name -match "power*"}
# Hands-on: For each process print its path

# Function
##########
function add {1+3}; add
function print-args {$args}; print-args 1 2
function add-args {$args[0] + $args[1]}
function add-pos($num1, $num2) {$num1 + $num2}

# Basic Scripting
#################
powershell.exe -ExecutionPolicy bypass
Get-ExecutionPolicy
Set-ExecutionPolicy Bypass
# .\script1.ps1
Get-ExecutionPolicy -List
Get-Content .runme.ps1 | PowerShell.exe -noprofile -

# System global info command
###########################
[System.Environment]::OSVersion.Version # Get the system's OS version
Write-Host 'PowerShell Version' $PsVersionTable.PSVersion  # PS version
[Environment]::Is64BitProcess  # Check if 64 bits
Get-HotFix # List all hotfixes
Get-TimeZone # Get the system's time zone
Get-WmiObject -Class Win32_BIOS # Get the system's BIOS information
Get-WmiObject -Class Win32_Processor # Get the system's CPU information
Get-WmiObject -Class Win32_PhysicalMemory # Get the system's memory information
Get-WmiObject -Class Win32_LogicalDisk # Get the system's disk information

# System running info command
#############################
Get-Process # List all running processes
Get-Service # List all services
Get-ChildItem Env: # Get the system's environment variables
[environment]::GetEnvironmentVariables( )
Get-WmiObject -Class Win32_UserAccount # List all users
Get-PSDrive # List all drives
Get-ScheduledTask # List all scheduled tasks
$(Get-Command ml64).Source  # Alternative to linux which

# System network info
#####################
Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled -eq $True } # Get the system's network configuration
Get-DnsClientServerAddress # Get the system's DNS settings
Get-NetFirewallRule # List all firewall rules
Get-NetTCPConnection # List all network connections
Get-NetAdapter | Select-Object -Property Name,MacAddress # Get the system's MAC address
Get-WmiObject -Class Win32_Share # List all network shares
Disable-NetFirewallRule -DisplayName "<FirewallRuleName>" # Disable a firewall rule
Enable-NetFirewallRule -DisplayName "<FirewallRuleName>" # Enable a firewall rule

# System interaction command
#############################
Stop-Process -ID 4242 # Kill a process by its ID
Start-Service -Name ServiceName # Start a service
Stop-Service -Name ServiceName # Stop a service
(Get-CimInstance -ClassName Win32_OperatingSystem).LastBootUpTime # Get the system's uptime
Get-WmiObject -Query "SELECT * FROM Win32_Product" # List all installed programs
Start-ScheduledTask -TaskName "<TaskName>" # Run a scheduled task
Stop-ScheduledTask -TaskName "<TaskName>" # Stop a scheduled task


################################
# ADVANCED PENTESTING COMMANDS #
################################

# Base64
[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("clear text"))
[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("Y2xlYXIgdGV4dA=="))

# Wget
(New-Object System.Net.WebClient).DownloadFile("http://example.com", "example.html")

# Nmap: ping sweep
1..255 | % {echo "10.10.10.$_";ping -n 1 -w 100 10.10.10.$_ | Select-String ttl}

# Nmap: port scan
1..1024 | % {echo ((new-object Net.Sockets.TcpClient).Connect("10.10.10.10",$_)) "Port $_ is open!"} 2>$null

# Assert
function assert(){
  $b_not = $false; if("not" -eq $args[0]){ $b_not = $true; $_, $args=$args; }
  $out = Invoke-Expression "$args"; $res = ($LASTEXITCODE -xor $b_not)
  echo "[$res] $args => $out"
}

# Pipeline
ls *.txt | ForEach-Object {cat $_}
Get-Process | Where-Object {$_.name â€“eq "notepad"}
1..10 | % {echo "Hello!"}

# Unix like
ls            # Get-ChildItem
  Get-ChildItem "C:\Users\" -recurse -include *.c
cd directory  # Set-Location
  cd HKLM:\     # Navigate the Windows registry
ps            # Get-Process
```
